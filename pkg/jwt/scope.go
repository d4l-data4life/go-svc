package jwt

import (
	"database/sql/driver"
	"encoding/json"
	"strings"

	"github.com/pkg/errors"
)

// constant values for scope tokens
const (
	TokenPermissionsRead   = "perm:r"
	TokenPermissionsWrite  = "perm:w"
	TokenRecordsRead       = "rec:r"
	TokenRecordsWrite      = "rec:w"
	TokenRecordsAppend     = "rec:a"
	TokenAttachmentsRead   = "attachment:r"
	TokenAttachmentsWrite  = "attachment:w"
	TokenAttachmentsAppend = "attachment:a"
	TokenUserRead          = "user:r"
	TokenUserWrite         = "user:w"
	TokenUserQuery         = "user:q"
	TokenUserKeysRead      = "ku:r"
	TokenUserKeysWrite     = "ku:w"
	TokenUserKeysAppend    = "ku:a"
	TokenAppKeysRead       = "ka:r"
	TokenAppKeysWrite      = "ka:w"
	TokenAppKeysAppend     = "ka:a"
	TokenDeviceRead        = "dev:r"
	TokenDeviceWrite       = "dev:w"
	TokenDeviceAppend      = "dev:a"
	TokenTerraDB           = "terradb"
	TokenTags              = "tag:*"
	TokenExtended          = "ext:*"
)

var (
	// ErrUnknownToken is the error that is returned
	// when encountering unknown scope tokens.
	ErrUnknownToken = errors.New("unknown token")

	// ErrScopeIsNotAString is returned when trying to parse an interface
	// whose underlying type is not string.
	ErrScopeIsNotAString = errors.New("scope is not a string")
)

var (
	// 24 is the minimal assumed base64-encrypted-tag length that will be generated by AES GCM with
	// 0 byte nonce with 256 bit key (default in the SDK) and a one char tag to encrypt.
	// +1 for the colons :)
	minTagLen = len(TagPrefix) + 25

	exists = struct{}{}

	KnownTokens = map[string]struct{}{
		TokenPermissionsRead:  exists,
		TokenPermissionsWrite: exists,

		TokenRecordsRead:   exists,
		TokenRecordsWrite:  exists,
		TokenRecordsAppend: exists,

		TokenAttachmentsRead:   exists,
		TokenAttachmentsWrite:  exists,
		TokenAttachmentsAppend: exists,

		TokenUserRead:  exists,
		TokenUserWrite: exists,
		TokenUserQuery: exists,

		TokenUserKeysRead:   exists,
		TokenUserKeysWrite:  exists,
		TokenUserKeysAppend: exists,

		TokenAppKeysRead:   exists,
		TokenAppKeysWrite:  exists,
		TokenAppKeysAppend: exists,

		TokenDeviceRead:   exists,
		TokenDeviceWrite:  exists,
		TokenDeviceAppend: exists,

		TokenTerraDB:  exists,
		TokenTags:     exists,
		TokenExtended: exists,
	}

	AllScopes = Scope{
		Tokens: []string{
			TokenPermissionsRead,
			TokenPermissionsWrite,
			TokenRecordsRead,
			TokenRecordsWrite,
			TokenRecordsAppend,
			TokenAttachmentsRead,
			TokenAttachmentsWrite,
			TokenAttachmentsAppend,
			TokenUserRead,
			TokenUserWrite,
			TokenUserQuery,
			TokenUserKeysRead,
			TokenUserKeysWrite,
			TokenUserKeysAppend,
			TokenAppKeysRead,
			TokenAppKeysWrite,
			TokenAppKeysAppend,
			TokenDeviceRead,
			TokenDeviceWrite,
			TokenDeviceAppend,
			TokenTerraDB,
		},
	}
)

// IsKnownToken is checking if the exact token is known to the package.
// This will not return true on a valid specific Tag, only for the general
// Tag token (tag:*).
func IsKnownToken(token string) bool {
	_, exists := KnownTokens[token]

	return exists
}

// Scope is the type that represents JWT/OAuth scope
// according to https://tools.ietf.org/html/rfc6749#section-3.3.
// It contains a list of scope tokens.
//
// It implements encoding the scope in OAuth compatible format
// as per https://tools.ietf.org/html/rfc6749#section-3.3
// as fmt.Stringer, json.Marshaler, and json.Unmarshaler.
type Scope struct {
	Tokens []string
}

var (
	_ json.Marshaler   = &Scope{}
	_ json.Unmarshaler = &Scope{}
)

// Contains iterates through the scope tokens in O(n)
// and returns true if the given scope is contained, else false.
func (s Scope) Contains(t string) bool {
	if len(s.Tokens) == 0 && t == "" {
		return true
	}

	for i := range s.Tokens {
		if s.Tokens[i] == t {
			return true
		}
	}

	return false
}

// NewScope converts the given requested scope string into a valid scope
// which can be used to issue access tokens.
//
// This function filters unknown requested scope tokens.
func NewScope(src string) (Scope, error) {
	var s Scope
	if src == "" {
		return s, nil
	}

	for _, token := range strings.Split(src, " ") {
		if !IsKnownToken(token) && !IsTag(token) && !IsExtendedToken(token) {
			return s, ErrUnknownToken
		}

		s.Tokens = append(s.Tokens, token)
	}

	return s, nil
}

// Tags parses the Tags from the Scope.
func (s Scope) Tags() (tags []Tag, err error) {
	for _, token := range s.Tokens {
		if IsTag(token) {
			tag, err := NewTag(token)
			if err != nil {
				return nil, err
			}

			tags = append(tags, tag)
		}
	}

	return
}

// ExtendedToken parses the ExtendedToken from the Scope.
func (s Scope) ExtendedToken() (exts []ExtendedToken, err error) {
	for _, token := range s.Tokens {
		if IsExtendedToken(token) {
			ext, err := NewExtendedToken(token)
			if err != nil {
				return nil, err
			}

			exts = append(exts, ext)
		}
	}

	return
}

// ContainsCodeGrantScope iterates through the scope tokens in O(n^2)
// It returns true if this scope contains the given scope,
// that is all tokens of the given scope are contained in this scope.
//
// It does work with a specific Tag. Therefore it returns truthy on e.g.
// tag:BgsIBQ0HAgcKAAEOCgsBDwIHDgcGAw0HBQcKDAUNCQQGBQoBBw8FDQUMCwUGDwYCAg0=
func (s Scope) ContainsCodeGrantScope(sc Scope) bool {
	for _, t := range sc.Tokens {
		// handles 1:1 matching and should suffice for Token and ExtendedToken.
		if s.Contains(t) {
			continue
		}

		// Checks for dynamic tag scope. Token should look like:
		// tag:BgsIBQ0HAgcKAAEOCgsBDwIHDgcGAw0HBQcKDAUNCQQGBQoBBw8FDQUMCwUGDwYCAg0=
		if s.Contains(TokenTags) && IsTag(t) && len(t) > minTagLen {
			continue
		}

		return false
	}

	return true
}

// FromCodeGrantTokens converts slice of strings into a Scope, if they
// are known Tokens or ExtendedToken. It returns ErrUnkownToken otherwise.
//
// It doesn't work with a specific Tag, only with the general Tag scope
// (tag:*). Therefore it is meant to just verify the Scopes given by
// clients.json.
func FromCodeGrantTokens(tokens []string) (Scope, error) {
	var s Scope
	for _, token := range tokens {
		if !IsKnownToken(token) && !IsExtendedToken(token) {
			return Scope{}, ErrUnknownToken
		}
		s.Tokens = append(s.Tokens, token)
	}

	return s, nil
}

// MarshalJSON is the method that encodes the scope as a JSON string
func (s Scope) MarshalJSON() ([]byte, error) {
	return []byte(`"` + s.String() + `"`), nil
}

// Value implements driver.Valuer for marshaling into SQL
func (s Scope) Value() (driver.Value, error) {
	return s.String(), nil
}

// Scan implements sql.Scanner for unmarshaling from SQL
func (s *Scope) Scan(src interface{}) error {
	str, ok := src.(string)
	if !ok {
		return ErrScopeIsNotAString
	}

	var err error
	*s, err = NewScope(str)

	return err
}

// UnmarshalJSON is the method that decodes the scope from a JSON string
func (s *Scope) UnmarshalJSON(src []byte) error {
	var scope string
	err := json.Unmarshal(src, &scope)
	if err != nil {
		return errors.Wrap(err, "error unmarshaling scope string")
	}

	res, err := NewScope(scope)
	if err != nil {
		return errors.Wrap(err, "error creating scope")
	}

	*s = res
	return nil
}

func (s Scope) String() string {
	return strings.Join(s.Tokens, " ")
}
